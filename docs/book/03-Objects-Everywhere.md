[TOC]

# 第三章 萬物皆物件

> 如果我們說另外一種不同的語言，我們會發覺一個不同的世界！— Ludwig Wittgenstein (1889-1951)

相比 C++ ，Java 是一種更純粹的物件導向程式語言。雖然它們都是混合語言，但在 Java 中，設計者們認為混合的作用並非像在 C++ 中那般重要。混合語言允許多種編程風格，這也是 C++ 支援向後相容 C 的原因。正因為 C++ 是 C 語言的超集，所以它也同時包含了許多 C 語言不具備的特性，這使得 C++ 在某些方面過於複雜。

 Java 語言假設你只進行物件導向編程。開始學習之前，我們需要將思維置於物件導向的世界。本章你將了解到 Java 程式的基本組成，學習在 Java 中萬物（幾乎）皆物件的思想。

<!-- You Manipulate Objects with References -->

## 物件操縱

“名字代表什麼？玫瑰即使不叫玫瑰，也依舊芬芳”。（引用自 莎士比亞，《羅密歐與朱麗葉》）。

所有的程式語言都會操縱記憶體中的元素。有時程式設計師必須要有意識地直接或間接地操縱它們。在 C/C++ 中，物件的操縱是透過指標來完成的。

Java 利用萬物皆物件的思想和單一一致的語法方式來簡化問題。雖萬物皆可為物件，但我們所操縱的標識符實際上只是對物件的“引用” [^1]。 舉例：我們可以用遙控器（引用）去操縱電視（物件）。只要擁有物件的“引用”，就可以操縱該“物件”。換句話說，我們無需直接接觸電視，就可透過遙控器（引用）自由地控制電視（物件）的頻道和音量。此外，沒有電視，遙控器也可以單獨存在。就是說，你僅僅有一個“引用”並不意味著你必然有一個與之關聯的“物件”。 

下面來建立一個 **String** 引用，用於儲存單詞或語句。程式碼範例：

```java
    String s;
```

這裡我們只是建立了一個 **String** 物件的引用，而非物件。直接拿來使用會出現錯誤：因為此時你並沒有給變數 `s` 賦值--指向任何物件。通常更安全的做法是：建立一個引用的同時進行初始化。程式碼範例：

```java
    String s = "asdf";
```

Java 語法允許我們使用帶雙引號的文字內容來初始化字串。同樣，其他類型的物件也有相應的初始化方式。

<!-- You Must Create All the Objects -->
## 物件建立

“引用”用來關聯“物件”。在 Java 中，通常我們使用`new`操作符來建立一個新物件。`new` 關鍵字代表：建立一個新的物件實例。所以，我們也可以這樣來表示前面的程式碼範例：

```java
    String s = new String("asdf");
```
以上展示了字串物件的建立過程，以及如何初始化生成字串。除了 **String** 類型以外，Java 本身自帶了許多現成的資料類型。除此之外，我們還可以建立自己的資料類型。事實上，這是 Java 程式設計中的一項基本上行為。在本書後面的學習中將會接觸到。

<!-- Where Storage Lives -->
### 資料儲存

那麼，程式在執行時是如何儲存的呢？尤其是記憶體是怎麼分配的。有5個不同的地方可以儲存資料：

1. **暫存器**（Registers）最快的儲存區域，位於 CPU 內部 [^2]。然而，暫存器的數量十分有限，所以暫存器根據需求進行分配。我們對其沒有直接的控制權，也無法在自己的程式裡找到暫存器存在的蹤跡（另一方面，C/C++ 允許開發者向編譯器建議暫存器的分配）。

2. **堆疊記憶體**（Stack）存在於一般記憶體 RAM（隨機訪問儲存器，Random Access Memory）區域中，可透過堆疊指標獲得處理器的直接支援。堆疊指標下移分配記憶體，上移釋放記憶體。這是一種僅次於暫存器的非常快速有效的分配儲存方式。建立程式時，Java 系統必須知道堆疊內儲存的所有項的生命週期。這種約束限制了程式的靈活性。因此，雖然在堆疊記憶體上存在一些 Java 資料（如物件引用），但 Java 物件本身的資料卻是儲存在堆記憶體的。

3. **堆記憶體**（Heap）這是一種通用的記憶體池（也在 RAM 區域），所有 Java 物件都存在於其中。與堆疊記憶體不同，編譯器不需要知道物件必須在堆記憶體上停留多長時間。因此，用堆記憶體儲存資料更具靈活性。建立一個物件時，只需用 `new` 指令實例化物件即可，當執行程式碼時，會自動在堆中進行內存分配。這種靈活性是有代價的：分配和清理堆記憶體要比堆疊記憶體需要更多的時間（如果可以用 Java 在堆疊記憶體上建立物件，就像在 C++ 中那樣的話）。隨著時間的推移，Java 的堆記憶體分配機制現在已經非常快，因此這不是一個值得關心的問題了。

4. **常量儲存**（Constant storage）常量值通常直接放在程式碼中，因為它們永遠不會改變。如需嚴格保護，可考慮將它們置於唯讀儲存器 ROM （唯讀儲存器，Read Only Memory）中 [^3]。

5. **非 RAM 儲存**（Non-RAM storage）資料完全存在於程式之外，在程式未執行以及脫離程式控制後依然存在。兩個主要的例子：（1）序列化物件：物件被轉換為位元組流，通常被發送到另一台機器；（2）持久化物件：物件被放置在磁碟上，即使程式終止，資料依然存在。這些儲存的方式都是將物件轉存於另一個介質中，並在需要時復原成一般的、基於 RAM 的物件。Java 為輕量級持久化提供了支援。而諸如 JDBC 和 Hibernate 這些類庫為使用資料庫儲存和檢索物件訊息提供了更複雜的支援。

<!-- Special Case: Primitive Types -->
### 基本類型的儲存

有一組類型在 Java 中使用頻率很高，它們需要特殊對待，這就是 Java 的基本類型。之所以這麼說，是因為它們的建立並不是透過 `new` 關鍵字來產生。通常 `new` 出來的物件都是儲存在堆記憶體中的，以此方式建立小而簡單的變數往往是不划算的。所以對於這些基本類型的建立方法，Java 使用了和 C/C++ 一樣的策略。也就是說，不是使用 `new` 建立變數，而是使用一個“自動”變數。 這個變數直接儲存"值"，並置於堆疊記憶體中，因此更加高效。

Java 確定了每種基本類型的記憶體占用大小。 這些大小不會像其他一些語言那樣隨著機器環境的變化而變化。這種不變性也是 Java 更具可移植性的一個原因。

| 基本類型  |    大小 |  最小值  | 最大值  | 包裝類型 |
| :------: | :------: | :------: | :------: | :------: |
| boolean | —  | — | — | Boolean |
| char | 16 bits | Unicode 0  | Unicode 2<sup>16</sup> -1  | Character |
| byte | 8 bits | -128 | +127 | Byte |
| short | 16 bits | - 2<sup>15</sup> | + 2<sup>15</sup> -1 | Short |
| int | 32 bits | - 2<sup>31</sup> | + 2<sup>31</sup> -1 | Integer |
| long | 64 bits | - 2<sup>63</sup> | + 2<sup>63</sup> -1 | Long |
| float | 32 bits | IEEE754 | IEEE754 | Float |
| double | 64 bits |IEEE754 | IEEE754 | Double |
| void | — | — | — | Void |

所有的數值類型都是有正/負符號的。布爾（boolean）類型的大小沒有明確的規定，通常定義為取字面值 “true” 或 “false” 。基本類型有自己對應的包裝類型，如果你希望在堆記憶體裡表示基本類型的資料，就需要用到它們的包裝類。程式碼範例：

```java
char c = 'x';
Character ch = new Character(c);
```
或者你也可以使用下面的形式：

```java
Character ch = new Character('x');
```

基本類型自動轉換成包裝類型（自動裝箱）

```java
Character ch = 'x';
```

相對的，包裝類型轉化為基本類型（自動拆箱）：

```java
char c = ch;
```

箇中原因將在以後的章節裡解釋。

<!-- High-Precision Numbers -->
### 高精度數值

在 Java 中有兩種類型的資料可用於高精度的計算。它們是 `BigInteger` 和 `BigDecimal`。儘管它們大致可以劃歸為“包裝類型”，但是它們並沒有對應的基本類型。

這兩個類包含的方法提供的操作，與對基本類型執行的操作相似。也就是說，能對 int 或 float 做的運算，在 BigInteger 和 BigDecimal 這裡也同樣可以，只不過必須要透過呼叫它們的方法來實現而非運算符。此外，由於涉及到的計算量更多，所以運算速度會慢一些。誠然，我們犧牲了速度，但換來了精度。

BigInteger 支援任意精度的整數。可用於精確表示任意大小的整數值，同時在運算過程中不會遺失精度。
BigDecimal 支援任意精度的定點數字。例如，可用它進行精確的貨幣計算。

關於這兩個類的詳細訊息，請參考 JDK 官方文件。

<!-- Arrays in Java -->
### 陣列的儲存

許多程式語言都支援陣列類型。在 C 和 C++ 中使用陣列是危險的，因為那些陣列只是記憶體塊。如果程式訪問了記憶體塊之外的陣列或在初始化之前使用該段記憶體（常見編程錯誤），則結果是不可預測的。

Java 的設計主要目標之一是安全性，因此許多困擾 C 和 C++ 程式設計師的問題不會在 Java 中再現。在 Java 中，陣列使用前需要被初始化，並且不能訪問陣列長度以外的資料。這種範圍檢查，是以每個陣列上少量的記憶體開銷及執行時檢查下標的額外時間為代價的，但由此換來的安全性和效率的提高是值得的。（並且 Java 經常可以最佳化這些操作）。

當我們建立物件陣列時，實際上是建立了一個引用陣列，並且每個引用的初始值都為 **null** 。在使用該陣列之前，我們必須為每個引用指定一個物件 。如果我們嘗試使用為 **null** 的引用，則會在執行時報錯。因此，在 Java 中就防止了陣列操作的一般錯誤。

我們還可建立基本類型的陣列。編譯器透過將該陣列的記憶體全部置零來保證初始化。本書稍後將詳細介紹陣列，特別是在陣列章節中。

<!-- Comments -->
## 程式碼注釋

Java 中有兩種類型的注釋。第一種是傳統的 C 風格的注釋，以 `/*` 開頭，可以跨越多行，到 `*/ ` 結束。注意，許多程式設計師在多行注釋的每一行開頭添加 `*`，所以你經常會看到：

```java
/* 這是
* 跨越多行的
* 注釋
*/
```

但請記住，`/*` 和 `*/` 之間的內容都是被忽略的。所以你將其改為下面這樣也是沒有區別的。

```java
/* 這是跨越多
行的注釋 */
```

第二種注釋形式來自 C++ 。它是單行注釋，以 `//` 開頭並一直持續到行結束。這種注釋方便且常用，因為直觀簡單。所以你經常看到：

```java
// 這是單行注釋
```

<!-- You Never Need to Destroy an Object -->
## 物件清理

在一些程式語言中，管理變數的生命週期需要大量的工作。一個變數需要存活多久？如果我們想銷毀它，應該什麼時候去做呢？變數生命週期的混亂會導致許多 bug，本小結向你介紹 Java 是如何透過釋放儲存來簡化這個問題的。

<!-- Scoping -->
### 作用域

大多數程式語言都有作用域的概念。作用域決定了在該範圍內定義的變數名的可見性和生存週期。在 C、 C++ 和 Java 中，作用域是由大括號 `{}` 的位置決定的。例如：

```java
{
    int x = 12;
    // 僅 x 變數可用
    {
        int q = 96;
        // x 和 q 變數皆可用
    }
    // 僅 x 變數可用
    // 變數 q 不在作用域內
}
```

Java 的變數只有在其作用域內才可用。縮排使得 Java 程式碼更易於閱讀。由於 Java 是一種自由格式的語言，額外的空格、定位符號和Enter並不會影響程式的執行結果。在 Java 中，你不能執行以下操作，即使這在 C 和 C++ 中是合法的：

```java
{
    int x = 12;
    {
        int x = 96; // Illegal
    }
}
```

在上例中， Java 編譯器會在提示變數 x 已經被定義過了。因此，在 C/C++ 中將一個較大作用域的變數"隱藏"起來的做法，在 Java 中是不被允許的。 因為 Java 的設計者認為這樣做會導致程式混亂。

<!-- Scope of Objects -->
### 物件作用域

Java 物件與基本類型具有不同的生命週期。當我們使用 `new` 關鍵字來建立 Java 物件時，它的生命週期將會超出作用域。因此，下面這段程式碼範例：

```java
{
    String s = new String("a string");
} 
// 作用域終點
```

上例中，引用 s 在作用域終點就結束了。但是，引用 s 指向的字串物件依然還在占用記憶體。在這段程式碼中，我們無法在這個作用域之後訪問這個物件，因為唯一對它的引用 s 已超出了作用域的範圍。在後面的章節中，我們還會學習怎麼在編程中傳遞和複製物件的引用。

只要你需要，`new` 出來的物件就會一直存活下去。 相比在 C++ 編碼中操作記憶體可能會出現的諸多問題，這些困擾在 Java 中都不復存在了。在 C++ 中你不僅要確保物件的記憶體在你操作的範圍內存在，還必須在使用完它們之後，將其銷毀。

那麼問題來了：我們在 Java 中並沒有主動清理這些物件，那麼它是如何避免 C++ 中出現的記憶體被填滿從而阻塞程式的問題呢？答案是：Java 的垃圾收集器會檢查所有 `new` 出來的物件並判斷哪些不再可達，繼而釋放那些被占用的記憶體，供其他新的物件使用。也就是說，我們不必擔心記憶體回收的問題了。你只需簡單建立物件即可。當其不再被需要時，能自行被垃圾收集器釋放。垃圾回收機制有效防止了因程式設計師忘記釋放記憶體而造成的“記憶體洩漏”問題。

<!-- Creating New Data Types: class -->
## 類的建立

### 類型

如果一切都是物件，那麼是什麼決定了某一類物件的外觀和行為呢？換句話說，是什麼確定了物件的類型？你可能很自然地想到 `type` 關鍵字。但是，事實上大多數物件導向的語言都使用 `class` 關鍵字類來描述一種新的物件。 通常在 `class` 關鍵字的後面的緊跟類的的名稱。如下程式碼範例：

```java
class ATypeName {
 // 這裡是類的內部
}
```

在上例中，我們引入了一個新的類型，儘管這個類裡只有一行注釋。但是我們一樣可以透過 `new` 關鍵字來建立一個這種類型的物件。如下：

```java
ATypeName a = new ATypeName();
```

到現在為止，我們還不能用這個物件來做什麼事（即不能向它發送任何有意義的消息），除非我們在這個類裡定義一些方法。

<!-- Fields -->
### 欄位

當我們建立好一個類之後，我們可以往類裡存放兩種類型的元素：方法（method）和欄位（field）。類的欄位可以是基本類型，也可以是引用類型。如果類的欄位是對某個物件的引用，那麼必須要初始化該引用將其關聯到一個實際的物件上（透過之前介紹的建立物件的方法）。每個物件都有用來儲存其欄位的空間。通常，欄位不在物件間共享。下面是一個具有某些欄位的類的程式碼範例：

```java
class DataOnly {
    int i;
    double d;
    boolean b;
}
```

這個類除了儲存資料之外什麼也不能做。但是，我們仍然可以透過下面的程式碼來建立它的一個物件：

```java
    DataOnly data = new DataOnly();
```

我們必須透過這個物件的引用來指定欄位值。格式：物件名稱.方法名稱或欄位名稱。程式碼範例：

```java
    data.i = 47;
    data.d = 1.1;
    data.b = false;
```

如果你想修改物件內部包含的另一個物件的資料，可以透過這樣的格式修改。程式碼範例：

```java
    myPlane.leftTank.capacity = 100;
```

你可以用這種方式嵌套許多物件（儘管這樣的設計會帶來混亂）。

<!-- Default Values for Primitive Members -->
### 基本類型預設值

如果類的成員變數（欄位）是基本類型，那麼在類初始化時，這些類型將會被賦予一個初始值。

| 基本類型 | 初始值 |
| :-----: |:-----: |
| boolean | false |
| char | \u0000 (null) |
| byte | (byte) 0 |
| short |(short) 0 |
| int | 0 |
| long | 0L |
| float | 0.0f |
| double | 0.0d |

這些預設值僅在 Java 初始化類的時候才會被賦予。這種方式確保了基本類型的欄位始終能被初始化（在 C++ 中不會），從而減少了 bug 的來源。但是，這些初始值對於程式來說並不一定是合法或者正確的。 所以，為了安全，我們最好始終顯式地初始化變數。

這種預設值的賦予並不適用於局部變數 —— 那些不屬於類的欄位的變數。 因此，若在方法中定義的基本類型資料，如下：

```java
    int x;
```

這裡的變數 x 不會自動初始化為0，因而在使用變數 x 之前，程式設計師有責任主動地為其賦值（和 C 、C++ 一致）。如果我們忘記了這一步， Java 將會提示我們“編譯時錯誤，該變數可能尚未被初始化”。 這一點做的比 C++ 更好，在後者中，編譯器只是提示警告，而在 Java 中則直接報錯。

<!-- Methods, Arguments,and Return Values -->
### 方法使用

在許多語言（如 C 和 C++）中，使用術語 *函數* (function) 用來命名子程序。在 Java 中，我們使用術語 *方法*（method）來表示“做某事的方式”。

在 Java 中，方法決定物件能接收哪些消息。方法的基本組成部分包括名稱、參數、返回類型、方法體。格式如：

```java
 [返回類型] [方法名](/*參數列表*/){
     // 方法體
 }
```

#### 返回類型

方法的返回類型表明了當你呼叫它時會返回的結果類型。參數列表則顯示了可被傳遞到方法內部的參數類型及名稱。方法名和參數列表統稱為**方法簽名**（signature of the method）。簽名作為方法的唯一標識。

Java 中的方法只能作為類的一部分建立。它只能被物件所呼叫 [^4]，並且該物件必須有權限來執行呼叫。若物件呼叫錯誤的方法，則程式將在編譯時報錯。

我們可以像下面這樣呼叫一個物件的方法：

```java
[物件引用].[方法名](參數1, 參數2, 參數3);
```

若方法不帶參數，例如一個物件引用 `a` 的方法 `f` 不帶參數並返回 **int** 型結果，我們可以如下表示：

```java
int x = a.f();
```

上例中方法 `f` 的返回值類型必須和變數 `x` 的類型相容 。呼叫方法的行為有時被稱為向物件發送消息。物件導向編程可以總結為：向物件發送消息。

<!-- The Argument List -->
#### 參數列表

方法參數列表指定了傳遞給方法的訊息。正如你可能猜到的，這些訊息就像 Java 中的其他所有訊息 ，以物件的形式傳遞。參數列表必須指定每個物件的類型和名稱。同樣，我們並沒有直接處理物件，而是在傳遞物件引用 [^5] 。但是引用的類型必須是正確的。如果方法需要 String 參數，則必須傳入 String，否則編譯器將報錯。

```java
int storage(String s) {
    return s.length() * 2;
}
```

此方法計算並返回某個字串所占的位元組數。參數 `s` 的類型為 **String** 。將 s 傳遞給 `storage()` 後，我們可以把它看作和任何其他物件一樣，可以向它發送消息。在這裡，我們呼叫 `length()` 方法，它是一個 String 方法，返回字串中的字元數。字串中每個字元的大小為 16 位或 2 個位元組。你還看到了 **return** 關鍵字，它執行兩項操作。首先，它意味著“方法執行結束”。其次，如果方法有返回值，那麼該值就緊跟 **return** 語句之後。這裡，返回值是透過計算

```java
s.length() * 2
```
產生的。在方法中，我們可以返回任何類型的資料。如果我們不想方法返回資料，則可以透過給方法標識 `void` 來表明這是一個無需返回值的方法。 程式碼範例：

```java
boolean flag() { 
    return true; 
}

double naturalLogBase() { 
    return 2.718; 
}

void nothing() {
     return;
}

void nothing2() {

}
```

當返回類型為 **void** 時， **return** 關鍵字僅用於退出方法，因此在方法結束處的 **return** 可被省略。我們可以隨時從方法中返回，但若方法返回類型為非 `void`，則編譯器會強制我們返回相應類型的值。

上面的描述可能會讓你感覺程式只不過是一堆包含各種方法的物件，在這些方法中，將物件作為參數並發送消息給其他物件。大部分情況下確實如此。但在下一章的運算符中我們將會學習如何在方法中做出決策來完成更底層、詳細的工作。對於本章，知道如何發送消息就夠了。

<!-- Writing a Java Program -->
## 程式編寫

在看到第一個 Java 程式之前，我們還必須理解其他幾個問題。

### 命名可見性

命名控制在任何一門程式語言中都是一個問題。如果你在兩個模組中使用相同的命名，那麼如何區分這兩個名稱，並防止兩個名稱發生“衝突”呢？在 C 語言編程中這是很具有挑戰性的，因為程式通常是一個無法管理的名稱海洋。C++ 將函數嵌套在類中，所以它們不會和嵌套在其他類中的函數名衝突。然而，C++ 還是允許全域資料和全域函數，因此仍有可能發生衝突。為了解決這個問題，C++ 使用附加的關鍵字引入了*命名空間*。

Java 採取了一種新的方法避免了以上這些問題：為一個類庫生成一個明確的名稱，Java 建立者希望我們反向使用自己的網路域名，因為域名通常是唯一的。因此我的域名是 MindviewInc.com，所以我將我的 foibles 類庫命名為 com.mindviewinc.utility.foibles。反轉域名後，`.` 用來代表子目錄的劃分。

在 Java 1.0 和 Java 1.1 中，域副檔名 com、 edu、 org 和 net 等按慣例大寫，因此類庫中會出現這樣類似的名稱：Com.mindviewinc.utility.foibles。然而，在 Java 2 的開發過程中，他們發現這會導致問題，所以現在整個包名都是小寫的。此機制意味著所有文件都自動存在於自己的命名空間中，文件中的每個類都具有唯一標識符。這樣，Java 語言可以防止名稱衝突。

使用反向 URL 是一種新的命名空間方法，在此之前尚未有其他語言這麼做過。Java 中有許多這些“創造性”地解決問題的方法。正如你想像，如果我們未經測試就添加一個功能並用於生產，那麼在將來發現該功能的問題再想糾正，通常為時已晚（有些錯誤太嚴重了就得從語言中刪除新功能。）

使用反向 URL 將命名空間與文件路徑相關聯不會導致BUG，但它卻給原始碼管理帶來麻煩。例如在 `com.mindviewinc.utility.foibles` 這樣的目錄結構中，我們建立了 `com` 和 `mindviewinc` 空目錄。它們存在的唯一目的就是用來表示這個反向的 URL。

這種方式似乎為我們在編寫 Java 程式中的某個問題打開了大門。空目錄填充了深層次結構，它們不僅用於表示反向 URL，還用於捕獲其他訊息。這些長路徑基本上用於儲存有關目錄中的內容的資料。如果你希望以最初設計的方式使用目錄，這種方法可以從“令人沮喪”到“令人抓狂”，對於生產級的 Java 程式碼，你必須使用專門為此設計的 IDE 來管理程式碼。例如 NetBeans，Eclipse 或 IntelliJ IDEA。實際上，這些 IDE 都為我們管理和建立深層次空目錄結構。

對於這本書中的例子，我不想讓深層次結構給你的學習帶來額外的麻煩，這實際上需要你在開始之前學習熟悉一種重量級的 IDE。所以，我們的每個章節的範例都位於一個淺的子目錄中，以章節標題為名。這導致我偶爾會與遵循深層次方法的工具發生衝突。

<!-- Using Other Components -->
### 使用其他元件

無論何時在程式中使用預先定義好的類，編譯器都必須找到該類。最簡單的情況下，該類存在於被呼叫的原始碼文件中。此時我們使用該類 —— 即使該類在文件的後面才會被定義（Java 消除了所謂的“前向引用”問題）。而如果一個類位於其他文件中，又會怎樣呢？你可能認為編譯器應該足夠智慧去找到它，但這樣是有問題的。想像一下，假如你要使用某個類，但目錄中存在多個同名的類（可能用途不同）。或者更糟糕的是，假設你正在編寫程式，在構建過程中，你想將某個新類添加到類庫中，但卻與已有的類名稱衝突。

要解決此問題，你必須透過使用 **import** 關鍵字來告訴 Java 編譯器具體要使用的類。**import** 指示編譯器匯入一個包，也就是一個類庫（在其他語言中，一個庫不僅包含類，還可能包括函數和資料，但請記住 Java 中的所有程式碼都必須寫在類裡）。大多數時候，我們都在使用 Java 標準庫中的元件。有了這些構件，你就不必寫一長串的反轉域名。例如：

```java
import java.util.ArrayList;
```

上例可以告訴編譯器使用位於標準庫 **util** 下的 ArrayList 類。但是，**util** 中包含許多類，我們可以使用萬用字元 `*` 來匯入其中部分類，而無需顯式得逐一聲明這些類。程式碼範例：

```java
import java.util.*;
```

本書中的範例很小，為簡單起見，我們通常會使用 `.*` 形式略過匯入。然而，許多教學書籍都會要求程式設計師逐一匯入每個類。 

<!-- The static Keyword -->
### static關鍵字

類是物件的外觀及行為方式的描述。通常只有在使用 `new` 建立那個類的物件後，資料儲存空間才被分配，物件的方法才能供外界呼叫。這種方式在兩種情況下是不足的。

1. 有時你只想為特定欄位（註：也稱為屬性、域）分配一個共享儲存空間，而不去考慮究竟要建立多少物件，甚至根本就不建立物件。

2. 建立一個與此類的任何物件無關的方法。也就是說，即使沒有建立物件，也能呼叫該方法。

**static** 關鍵字（從 C++ 採用）就符合上述兩點要求。當我們說某個事物是靜態時，就意味著該欄位或方法不依賴於任何特定的物件實例 。 即使我們從未建立過該類的物件，也可以呼叫其靜態方法或訪問其靜態欄位。相反，對於普通的非靜態欄位和方法，我們必須要先建立一個物件並使用該物件來訪問欄位或方法，因為非靜態欄位和方法必須與特定物件關聯 [^6] 。

一些物件導向的語言使用類資料（class data）和類方法（class method），表示靜態資料和方法只是作為類，而不是類的某個特定物件而存在的。有時 Java 文獻也使用這些術語。

我們可以在類的欄位或方法前添加 `static` 關鍵字來表示這是一個靜態欄位或靜態方法。 程式碼範例：

```java
class StaticTest {
    static int i = 47;
}
```

現在，即使你建立了兩個 `StaticTest` 物件，但是靜態變數 `i` 仍只占一份儲存空間。兩個物件都會共享相同的變數 `i`。 程式碼範例：

```java
StaticTest st1 = new StaticTest();
StaticTest st2 = new StaticTest();
```

`st1.i` 和 `st2.i` 指向同一塊儲存空間，因此它們的值都是 47。引用靜態變數有兩種方法。在前面的範例中，我們透過一個物件來定位它，例如 `st2.i`。我們也可以透過類名直接引用它，這種方式對於非靜態成員則不可行：

```java
StaticTest.i++;
```

`++` 運算符將會使變數結果 + 1。此時 `st1.i` 和 `st2.i` 的值都變成了 48。

使用類名直接引用靜態變數是首選方法，因為它強調了變數的靜態屬性。類似的邏輯也適用於靜態方法。我們可以透過物件引用靜態方法，就像使用任何方法一樣，也可以透過特殊的語法方式 `Classname.method()` 來直接呼叫靜態欄位或方法 [^7]。 程式碼範例：

```java
class Incrementable {
    static void increment() { 
      StaticTest.i++; 
    }
}
```

上例中，`Incrementable` 的 `increment()` 方法透過 `++` 運算符將靜態資料 `i` 加 1。我們依然可以先實例化物件再呼叫該方法。 程式碼範例：

```java
Incrementable sf = new Incrementable();
sf.increment();
```

當然了，首選的方法是直接透過類來呼叫它。程式碼範例：

```java
Incrementable.increment()；
```

相比非靜態的物件，`static` 屬性改變了資料建立的方式。同樣，當 `static` 關鍵字修飾方法時，它允許我們無需建立物件就可以直接透過類的引用來呼叫該方法。正如我們所知，`static` 關鍵字的這些特性對於應用程式入口點的 `main()` 方法尤為重要。

<!-- Your First Java Program -->
## 小試牛刀

最後，我們開始編寫第一個完整的程式。我們使用 Java 標準庫中的 **Date** 類來展示一個字串和日期。

```java

// objects/HelloDate.java
import java.util.*;

public class HelloDate {
    public static void main(String[] args) {
        System.out.println("Hello, it's: ");
        System.out.println(new Date());
    }
}

```

在本書中，所有程式碼範例的第一行都是注釋行，其中包含文件的路徑訊息（比如本章的目錄名是 **objects**），後跟檔案名。我的工具可以根據這些訊息自動提取和測試書籍的程式碼，你也可以透過參考第一行注釋輕鬆地在 Github 庫中找到對應的程式碼範例。

如果你想在程式碼中使用一些額外的類庫，那麼就必須在程式文件的開始處使用 **import** 關鍵字來匯入它們。之所以說是額外的，因為有一些類庫已經預設自動匯入到每個文件裡了。例如：`java.lang` 包。

現在打開你的瀏覽器在 [Oracle](https://www.oracle.com/) 上查看文件。如果你還沒有從 [Oracle](https://www.oracle.com/) 網站上下載 JDK 文件，那現在就去 [^8] 。查看包列表，你會看到 Java 附帶的所有不同的類庫。

選擇 `java.lang`，你會看到該庫中所有類的列表。由於 `java.lang` 隱式包含在每個 Java 程式碼文件中，因此這些類是自動可用的。`java.lang` 類庫中沒有 **Date** 類，所以我們必須匯入其他的類庫(即 Date 所在的類庫)。如果你不清楚某個類所在的類庫或者想查看類庫中所有的類，那麼可以在 Java 文件中選擇 “Tree” 查看。

現在，我們可以找到 Java 附帶的每個類。使用瀏覽器的“尋找”功能尋找 **Date**，搜尋結果中將會列出 **java.util.Date**，我們就知道了 **Date** 在 **util** 庫中，所以必須匯入 **java.util.*** 才能使用 **Date**。

如果你在文件中選擇 **java.lang**，然後選擇 **System**，你會看到 **System** 類中有幾個欄位，如果你選擇了 **out**，你會發現它是一個靜態的 **PrintStream** 物件。 所以，即使我們不使用 **new** 建立， **out** 物件就已經存在併可以使用。 **out** 物件可以執行的操作取決於它的類型： **PrintStream** ，其在文件中是一個超連結，如果單擊該連結，我們將可以看到 **PrintStream** 對應的方法列表（更多詳情，將在本書後面介紹）。 現在我們重點說的是 **println()** 這個方法。 它的作用是 “將訊息輸出到控制台，並以換行符結束”。既然如此，我們可以這樣編碼來輸出訊息到控制台。 程式碼範例：

```java
System.out.println("A String of things");
```

每個 java 來源文件中允許有多個類。同時，來源文件的名稱必須要和其中一個類名相同，否則編譯器將會報錯。每個獨立的程式應該包含一個 `main()` 方法作為程式執行的入口。其方法簽名和返回類型如下。程式碼範例：

```java
public static void main(String[] args) {
}
```

關鍵字 **public** 表示方法可以被外界訪問到。（ 更多詳情將在 **隱藏實現** 章節講到）
**main()** 方法的參數是一個 字串（**String**） 陣列。 參數 **args** 並沒有在目前的程式中使用到，但是 Java 編譯器強制要求必須要有， 這是因為它們被用於接收從命令列輸入的參數。

下面我們來看一段有趣的程式碼：

```java
System.out.println(new Date());
```

上面的範例中，我們建立了一個日期（**Date**）類型的物件並將其轉化為字串類型，輸出到控制台中。 一旦這一行語句執行完畢，我們就不再需要該日期物件了。這時，Java 垃圾回收器就可以將其占用的記憶體回收，我們無需去主動清除它們。

查看 JDK 文件時，我們可以看到在 **System** 類下還有很多其他有用的方法（ Java 的厲害之處還在於，它擁有一個龐大的標準庫資源）。程式碼範例：

```java
// objects/ShowProperties.java
public class ShowProperties {
    public static void main(String[] args) {
        System.getProperties().list(System.out);
        System.out.println(System.getProperty("user.name"));
        System.out.println(System.getProperty("java.library.path"));
    }
}
```

輸出結果(前20行):

```text
java.runtime.name=Java(TM) SE Runtime Environment
sun.boot.library.path=C:\Program
Files\Java\jdk1.8.0_112\jr...
java.vm.version=25.112-b15
java.vm.vendor=Oracle Corporation
java.vendor.url=http://java.oracle.com/
path.separator=;
java.vm.name=Java HotSpot(TM) 64-Bit Server VM
file.encoding.pkg=sun.io
user.script=
user.country=US
sun.java.launcher=SUN_STANDARD
sun.os.patch.level=
java.vm.specification.name=Java Virtual Machine
Specification
user.dir=C:\Users\Bruce\Documents\GitHub\on-ja...
java.runtime.version=1.8.0_112-b15
java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment
java.endorsed.dirs=C:\Program
Files\Java\jdk1.8.0_112\jr...
os.arch=amd64
java.io.tmpdir=C:\Users\Bruce\AppData\Local\Temp\
```

`main()` 方法中的第一行會輸出所有的系統欄位，也就是環境訊息。 **list()** 方法將結果發送給它的參數 **System.out**。在本書的後面，我們還會接觸到將結果輸出到其他地方，例如文件中。另外，我們還可以請求特定的欄位。該例中我們使用到了 **user.name** 和 **java.library.path**。 

<!-- Compiling and Running -->
### 編譯和執行

要編譯和執行本書中的程式碼範例，首先必須具有 Java 編程環境。 第二章的範例中描述了安裝過程。如果你遵循這些說明，那麼你將會在不受 Oracle 的限制的條件下用到 Java 開發工具包（JDK）。如果你使用其他開發系統，請查看該系統的文件以確定如何編譯和執行程式。 第二章還介紹了如何安裝本書的範例。 

移動到子目錄 **objects** 下並鍵入：

``` bash
javac HelloDate.java
```

此指令不應產生任何響應。如果我們收到任何類型的錯誤消息，則表示未正確安裝 JDK，那就得檢查這些問題。

若執行不報錯的話，此時可以鍵入：

```java
java HelloDate
```
我們將會得到正確的日期輸出。這是我們編譯和執行本書中每個程式（包含 `main()` 方法）的過程 [^9]。此外，本書的原始碼在根目錄中也有一個名為 **build.gradle** 的文件，其中包含用於自動構建，測試和執行本書文件的 **Gradle** 配置。當你第一次執行 `gradlew` 指令時，**Gradle** 將自動安裝（前提是已安裝Java）。

<!-- Coding Style -->
## 編碼風格

Java 程式語言編碼規範（Code Conventions for the Java Programming Language）[^10] 要求類名的首字母大寫。 如果類名是由多個單詞構成的，則每個單詞的首字母都應大寫（不採用下劃線來分隔）例如：

```java
class AllTheColorsOfTheRainbow {
    // ...
}
```

有時稱這種命名風格叫“駝峰命名法”。對於幾乎所有其他方法，欄位（成員變數）和物件引用名都採用駝峰命名的方式，但是它們的首字母不需要大寫。程式碼範例：

```java
class AllTheColorsOfTheRainbow {
    int anIntegerRepresentingColors;
    void changeTheHueOfTheColor(int newHue) {
        // ...
    }
    // ...
}

```

在 Oracle 的官方類庫中，花括號的位置同樣遵循和本書中上述範例相同的規範。

## 本章小結

本章向你展示了簡單的 Java 程式編寫以及該語言相關的基本概念。到目前為止，我們的範例都只是些簡單的順序執行。在接下來的兩章裡，我們將會接觸到 Java 的一些基本操作符，以及如何去控制程式執行的流程。

[^1]: 這裡可能有爭議。有人說這是一個指標，但這假定了一個潛在的實現。此外，Java 引用的語法更類似於 C++ 引用而非指標。在 《Thinking in Java》 的第 1 版中，我發明了一個新術語叫“句柄”（handle），因為 C++ 引用和Java 引用有一些重要的區別。作為一個從 C++ 的過來人，我不想混淆 Java 可能的最大受眾 —— C++ 程式設計師。在《Thinking in Java》的第 2 版中，我認為“引用”（reference）是更常用的術語，從 C++ 轉過來的人除了引用的術語之外，還有很多東西需要處理，所以他們不妨雙腳都跳進去。但是，也有些人甚至不同意“引用”。在某書中我讀到一個觀點：Java 支援引用傳遞的說法是完全錯誤的，因為 Java 物件標識符（根據該作者）實際上是“物件引用”（object references），並且一切都是值傳遞。所以你不是透過引用傳遞，而是“透過值傳遞物件引用。人們可以質疑我的這種解釋的準確性，但我認為我的方法簡化了對概念的理解而又沒對語言造成傷害（嗯，語言專家可能會說我騙你，但我會說我只是對此進行了適當的抽象。）

[^2]: 大多數微處理器晶片都有額外的高速緩衝儲存器，但這是按照傳統儲存器而不是暫存器。

[^3]: 一個例子是字串常量池。所有文字字串和字串值常量表達式都會自動放入特殊的靜態儲存中。

[^4]: 靜態方法，我們很快就能接觸到，它可以在沒有物件的情況下直接被類呼叫。

[^5]: 通常除了前面提到的“特殊”資料類型 boolean、 char、 byte、 short、 int、 long、 float 和 double。通常來說，傳遞物件就意味者傳遞物件的引用。

[^6]: 靜態方法在使用之前不需要建立物件，因此它們不能直接呼叫非靜態的成員或方法（因為非靜態成員和方法必須要先實例化為物件才可以被使用）。

[^7]: 在某些情況下，它還為編譯器提供了更好的最佳化可能。

[^8]: 請注意，此文件未包含在 JDK 中;你必須單獨下載才能獲得它。

[^9]: 對於本書中編譯和執行命令列的每個程式，你可能還需要設定 CLASSPATH 。

[^10]: 為了保持本書的程式碼排版緊湊，我並沒完全遵守規範，但我儘量會做到符合 Java 標準。

<!-- 分頁 -->
<div style="page-break-after: always;"></div>
