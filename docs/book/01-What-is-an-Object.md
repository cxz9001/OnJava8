
# 第一章 物件的概念

> “我們沒有意識到慣用語言的結構有多大的力量。可以毫不誇張地說，它透過語義反應機制奴役我們。語言表現出來並在無意識中給我們留下深刻印象的結構會自動投射到我們周圍的世界。”  -- Alfred Korzybski (1930)

電腦革命的起源來自機器。程式語言就像是那台機器。它不僅是我們思維放大的工具與另一種表達媒介，更像是我們思想的一部分。語言的靈感來自其他形式的表達，如寫作，繪畫，雕塑，動畫和電影製作。程式語言就是建立應用程式的思想結構。

物件導向編程（Object-Oriented Programming OOP）是一種編程思維方式和編碼架構。本章講述 OOP 的基本概述。如果讀者對此不太理解，可先行跳過本章。等你具備一定編程基礎後，請務必再回頭看。只有這樣你才能深刻理解物件導向編程的重要性及設計方式。

## 抽象

所有程式語言都提供抽象機制。從某種程度上來說，問題的複雜度直接取決於抽象的類型和質量。這裡的“類型”意思是：抽象的內容是什麼？組語語言是對底層機器的輕微抽象。接著出現的“指令式”語言（如 FORTRAN，BASIC 和 C）是對組語語言的抽象。與組語相比，這類語言已有了長足的改進，但它們的抽象原理依然要求我們著重考慮電腦的結構，而非問題本身的結構。

程式設計師必須要在機器模型（“解決方案空間”）和實際解決的問題模型（“問題空間”）之間建立起一種關聯。這個過程既費精力，又脫離程式語言本身的範疇。這使得程式碼很難編寫，維護代價高昂。同時還造就了一個副產業“編程方法”學科。

為機器建模的另一個方法是為要解決的問題製作模型。對一些早期語言來說，如 LISP 和 APL，它們的做法是“從不同的角度觀察世界”——“所有問題都歸納為列表”或“所有問題都歸納為演算法”。PROLOG 則將所有
問題都歸納為決策鏈。對於這些語言，我們認為它們一部分是“基於約束”的程式，另一部分則是專為
處理圖形符號設計的（後者被證明限制性太強）。每種方法都有自己特殊的用途，適合解決某一類的問題。只要超出了它們力所能及的範圍，就會顯得非常笨拙。

物件導向的程式設計在此基礎上跨出了一大步，程式設計師可利用一些工具表達“問題空間”內的元素。由於這種表達非常具有普遍性，所以不必受限於特定類型的問題。我們將問題空間中的元素以及它們在解決方案空間的表示稱作“物件”（**Object**）。當然，還有一些在問題空間沒有對應的物件體。透過添加新的物件類型，程式可進行靈活的調整，以便與特定的問題配合。所以當你在閱讀描述解決方案的程式碼時，也是在閱讀問題的表述。與我們以前見過的相比，這無疑是一種更加靈活、更加強大的語言抽象方法。總之，OOP 允許我們根據問題來描述問題，而不是根據執行解決方案的電腦。然而，它仍然與電腦有聯繫，每個物件都類似一台小電腦：它們有自己的狀態並且可以進行特定的操作。這與現實世界的“物件”或者“物體”相似：它們都有自己的特徵和行為。

Smalltalk 作為第一個成功的物件導向並影響了 Java 的程式設計語言 ，*Alan Kay* 總結了其五大基本特徵。透過這些特徵，我們可理解“純粹”的物件導向程式設計方法是什麼樣的：

> 1. **萬物皆物件**。你可以將物件想像成一種特殊的變數。它儲存資料，但可以在你對其“發出請求”時執行本身的操作。理論上講，你總是可以從要解決的問題身上抽象出概念性的元件，然後在程式中將其表示為一個物件。
> 2. **程式是一組物件，透過消息傳遞來告知彼此該做什麼**。要請求呼叫一個物件的方法，你需要向該物件發送消息。
> 3. **每個物件都有自己的儲存空間，可容納其他物件**。或者說，透過封裝現有物件，可製作出新型物件。所以，儘管物件的概念非常簡單，但在程式中卻可達到任意高的複雜程度。
> 4. **每個物件都有一種類型**。根據語法，每個物件都是某個“類”的一個“實例”。其中，“類”（Class）是“類型”（Type）的同義詞。一個類最重要的特徵就是“能將什麼消息發給它？”。
> 5. **同一類所有物件都能接收相同的消息**。這實際是別有含義的一種說法，大家不久便能理解。由於類型為“圓”（Circle）的一個物件也屬於類型為“形狀”（Shape）的一個物件，所以一個圓完全能接收發送給"形狀”的消息。這意味著可讓程式碼統一指揮“形狀”，令其自動控制所有符合“形狀”描述的物件，其中自然包括“圓”。這一特性稱為物件的“可取代性”，是OOP最重要的概念之一。

*Grady Booch* 提供了對物件更簡潔的描述：一個物件具有自己的狀態，行為和標識。這意味著物件有自己的內部資料(提供狀態)、方法 (產生行為)，並彼此區分（每個物件在記憶體中都有唯一的地址）。

## 介面

亞里斯多德（*Aristotle*）大概是第一個認真研究“類型”的哲學家，他曾提出過“魚類和鳥類”這樣的概念。所有物件都是唯一的，但同時也是具有相同的特性和行為的物件所歸屬的類的一部分。這種思想被首次應用於第一個物件導向程式語言 Simula-67，它在程式中使用基本關鍵字 **class** 來引入新的類型（class 和 type 通常可互換使用，有些人對它們進行了進一步區分，他們強調 type 決定了介面，而 class 是那個介面的一種特殊實現方式）。

Simula 是一個很好的例子。正如這個名字所暗示的，它的作用是“模擬”（Simulate）類似“銀行出納員”這樣的經典問題。在這個例子裡，我們有一系列出納員、客戶、帳號、交易和貨幣單位等許多"物件”。每類成員（元素）都具有一些通用的特徵：每個帳號都有一定的餘額；每名出納都能接收客戶的存款；等等。與此同時，每個成員都有自己的狀態；每個帳號都有不同的餘額；每名出納都有一個名字。所以在電腦程式中，能用獨一無二的實體分別表示出納員、客戶、帳號以及交易。這個實體便是“物件”，而且每個物件都隸屬一個特定的“類”，那個類具有自己的通用特徵與行為。

因此，在物件導向的程式設計中，儘管我們真正要做的是建立各式各樣的資料“類型”（Type），但幾乎所有物件導向的程式設計語言都採用了 `class` 關鍵字。當你看到 “type” 這個詞的時候，請同時想到 `class`；反之亦然。

建立好一個類後，可根據情況生成許多物件。隨後，可將那些物件作為要解決問題中存在的元素進行處理。事實上，當我們進行物件導向的程式設計時，面臨的最大一項挑戰是：如何在“問題空間”（問題實際存在的地方）的元素與“方案空間”（對實際問題進行建模的地方，如電腦）的元素之間建立理想的“一對一”的映射關係。

那麼如何利用物件完成真正有用的工作呢？必須有一種辦法能向物件發出請求，令其解決一些實際的問題，比如完成一次交易、在螢幕上畫一些東西或者打開一個開關等等。每個物件僅能接受特定的請求。我們向物件發出的請求是透過它的“介面”（Interface）定義的，物件的“類型”或“類”則規定了它的介面形式。“類型”與“介面”的對應關係是物件導向程式設計的基礎。

下面讓我們以電燈泡為例：

![reader](../images/reader.png)

```java
Light lt = new Light();
lt.on();
```

在這個例子中，類型／類的名稱是 **Light**，可向 **Light** 物件發出的請求包括打開 `on`、關閉 `off`、變得更明亮 `brighten` 或者變得更暗淡 `dim`。透過聲明一個引用，如 `lt` 和 `new` 關鍵字，我們建立了一個 **Light** 類型的物件，再用等號將其賦給引用。

為了向物件發送消息，我們使用句點符號 `.` 將 `lt` 和消息名稱 `on` 連接起來。可以看出，使用一些預先定義好的類時，我們在程式裡採用的程式碼是非常簡單直觀的。

上圖遵循 **UML**（Unified Modeling Language，統一建模語言）的格式。每個類由一個框表示，框的頂部有類型名稱，框中間部分是要描述的任何資料成員，方法（屬於此物件的方法，它們接收任何發送到該物件的消息）在框的底部。通常，只有類的名稱和公共方法在 **UML** 設計圖中顯示，因此中間部分未顯示，如本例所示。如果你只對類名感興趣，則也不需要顯示方法訊息。

## 服務提供

在開發或理解程式設計時，我們可以將物件看成是“服務提供者”。你的程式本身將為使用者提供服務，並且它能透過呼叫其他物件提供的服務來實現這一點。我們的最終目標是開發或呼叫工具庫中已有的一些物件，提供理想的服務來解決問題。

那麼問題來了：我們該選擇哪個物件來解決問題呢？例如，你正在開發一個記事本程式。*你可能會想到在螢幕輸入預設的記事本物件*，一個用於檢測不同類型印表機並執行列印的物件。這些物件中的某些已經有了。那對於還沒有的物件，我們該設計成什麼樣呢？這些物件需要提供哪些服務，以及還需要呼叫其他哪些物件？

我們可以將這些問題一一分解，抽象成一組服務。軟體設計的基本原則是高內聚：每個元件的內部作用明確，功能緊密相關。然而經常有人將太多功能塞進一個物件中。例如：在支票列印模組中，你需要設計一個可以同時讀取文字格式又能正確識別不同印表機型號的物件。正確的做法是提供三個或更多物件：一個物件檢查所有排版布局的目錄；一個或一組可以識別不同印表機型號的物件展示通用的列印介面；第三個物件組合上述兩個服務來完成任務。這樣，每個物件都提供了一組緊密的服務。在良好的物件導向設計中，每個物件功能單一且高效。這樣的程式設計可以提高我們程式碼的復用性，同時也方便別人閱讀和理解我們的程式碼。只有讓人知道你提供什麼服務，別人才能更好地將其應用到其他模組或程式中。

## 封裝

我們可以把編程的側重領域劃分為研發和應用。應用程式員呼叫研發程式設計師構建的基礎工具類來做快速開發。研發程式設計師開發一個工具類，該工具類僅向應用程式員公開必要的內容，並隱藏內部實現的細節。這樣可以有效地避免該工具類被錯誤的使用和更改，從而減少程式出錯的可能。彼此職責劃分清晰，相互協作。當應用程式員呼叫研發程式設計師開發的工具類時，雙方建立了關係。應用程式員透過使用現成的工具類組裝應用程式或者構建更大的工具庫。如果工具類的建立者將類的內部所有訊息都公開給呼叫者，那麼有些使用規則就不容易被遵守。因為前者無法保證後者是否會按照正確的規則來使用，甚至是改變該工具類。只有設定訪問控制，才能從根本上阻止這種情況的發生。

因此，使用訪問控制的原因有以下兩點：

1. 讓應用程式員不要觸摸他們不應該觸摸的部分。（請注意，這也是一個哲學決策。部分程式語言認為如果程式設計師有需要，則應該讓他們訪問細節部分。）；

2. 使類庫的建立者（研發程式設計師）在不影響後者使用的情況下完善更新工具庫。例如，我們開發了一個功能簡單的工具類，後來發現可以透過最佳化程式碼來提高執行速度。假如工具類的介面和實現部分明確分開並受到保護，那我們就可以輕鬆地完成改造。

Java 有三個顯式關鍵字來設定類中的訪問權限：`public`（公開），`private`（私有）和`protected`（受保護）。這些訪問修飾符決定了誰能使用它們修飾的方法、變數或類。

 1. `public`（公開）表示任何人都可以訪問和使用該元素；

 2. `private`（私有）除了類本身和類內部的方法，外界無法直接訪問該元素。`private` 是類和呼叫者之間的屏障。任何試圖訪問私有成員的行為都會報編譯時錯誤；

 3. `protected`（受保護）類似於 `private`，區別是子類（下一節就會引入繼承的概念）可以訪問 `protected` 的成員，但不能訪問 `private` 成員；

 4. `default`（預設）如果你不使用前面的三者，預設就是 `default` 訪問權限。`default` 被稱為包訪問，因為該權限下的資源可以被同一包（庫元件）中其他類的成員訪問。

## 復用

一個類經建立和測試後，理應是可復用的。然而很多時候，由於程式設計師沒有足夠的程式經驗和遠見，我們的程式碼復用性並不強。

程式碼和設計方案的復用性是物件導向程式設計的優點之一。我們可以透過重複使用某個類的物件來達到這種復用性。同時，我們也可以將一個類的物件作為另一個類的成員變數使用。新的類可以是由任意數量和任意類型的其他物件構成。這裡涉及到“組合”和“聚合”的概念：

* **組合**（Composition）經常用來表示“擁有”關係（has-a relationship）。例如，“汽車擁有引擎”。

* **聚合**（Aggregation）動態的**組合**。

![UML-example](../images/1545758268350.png)

上圖中實心三角形指向“ **Car** ”表示 **組合** 的關係；如果是 **聚合** 關係，可以使用空心三角形。

（**譯者注**：組合和聚合都屬於關聯關係的一種，只是額外具有整體-部分的意義。至於是聚合還是組合，需要根據實際的業務需求來判斷。可能相同超類和子類，在不同的業務場景，關聯關係會發生變化。只看程式碼是無法區分聚合和組合的，具體是哪一種關係，只能從語義級別來區分。聚合關係中，整件不會擁有部件的生命週期，所以整件刪除時，部件不會被刪除。再者，多個整件可以共享同一個部件。組合關係中，整件擁有部件的生命週期，所以整件刪除時，部件一定會跟著刪除。而且，多個整件不可以同時共享同一個部件。這個區別可以用來區分某個關聯關係到底是組合還是聚合。兩個類生命週期不同步，則是聚合關係，生命週期同步就是組合關係。）

使用“組合”關係給我們的程式帶來極大的靈活性。通常建立的類中，成員物件會使用 `private` 訪問權限，這樣應用程式員則無法對其直接訪問。我們就可以在不影響客戶程式碼的前提下，從容地修改那些成員。我們也可以在“執行時"改變成員物件從而動態地改變程式的行為，這進一步增大了靈活性。下面一節要講到的“繼承”並不具備這種靈活性，因為編譯器對透過繼承建立的類進行了限制。

在物件導向編程中經常重點強調“繼承”。在新手程式設計師的印象裡，或許先入為主地認為“繼承應當隨處可見”。沿著這種思路產生的程式設計通常拙劣又複雜。相反，在建立新類時首先要考慮“組合”，因為它更簡單靈活，而且設計更加清晰。等我們有一些編程經驗後，一旦需要用到繼承，就會明顯意識到這一點。

## 繼承

“物件”的概念給編程帶來便利。它在概念上允許我們將各式各樣的資料和功能封裝到一起，這樣便可恰當表達“問題空間”的概念，而不用受制於必須使用底層機器語言。

透過使用 `class` 關鍵字，這些概念形成了程式語言中的基本單元。遺憾的是，這麼做還是有很多麻煩：在建立了一個類之後，即使另一個新類與其具有相似的功能，你還是得重新建立一個新類。但我們若能利用現成的資料類型，對其進行“複製”，再根據情況進行添加和修改，情況就顯得理想多了。“繼承”正是針對這個目標而設計的。但繼承並不完全等價於複製。在繼承過程中，若原始類（正式名稱叫作基類、超類或父類）發生了變化，修改過的“複製”類（正式名稱叫作繼承類或者子類）也會反映出這種變化。

![Inheritance-example](../images/1545763399825.png)

這個圖中的箭頭從衍生類指向基類。正如你將看到的，通常有多個衍生類。類型不僅僅描述一組物件的約束，它還涉及其他類型。兩種類型可以具有共同的特徵和行為，但是一種類型可能包含比另一種類型更多的特徵，並且還可以處理更多的消息（或者以不同的方式處理它們）。繼承透過基類和衍生類的概念來表達這種相似性。基類包含衍生自它的類型之間共享的所有特徵和行為。建立基類以表示思想的核心。從基類中衍生出其他類型來表示實現該核心的不同方式。

![1545764724202](../images/1545764724202.png)

例如，垃圾回收機對垃圾進行分類。基類是“垃圾”。每塊垃圾都有重量、價值等特性，它們可以被切碎、熔化或分解。在此基礎上，可以透過添加額外的特性（瓶子有顏色，鋼罐有磁性）或行為（鋁罐可以被壓碎）衍生出更具體的垃圾類型。此外，一些行為可以不同（紙張的價值取決於它的類型和狀態）。使用繼承，你將構建一個類型層次結構，來表示你試圖解決的某種類型的問題。第二個例子是常見的“形狀”例子，可能用於電腦輔助設計系統或遊戲模擬。基類是“形狀”，每個形狀都有大小、顏色、位置等等。每個形狀可以繪製、擦除、移動、著色等。由此，可以衍生出（繼承出）具體類型的形狀——圓形、正方形、三角形等等——每個形狀可以具有附加的特徵和行為。

![1545764780795](../images/1545764780795.png)

例如，某些形狀可以翻轉。有些行為可能不同，比如計算形狀的面積。類型層次結構體現了形狀之間的相似性和差異性。以相同的術語將解決方案轉換成問題是有用的，因為你不需要在問題描述和解決方案描述之間建立許多中間模型。透過使用物件，類型層次結構成為了主要模型，因此你可以直接從真實世界中對系統的描述過渡到用程式碼對系統進行描述。事實上，有時候，那些善於尋找複雜解決方案的人會被物件導向設計的簡單性難倒。從現有類型繼承建立新類型。這種新類型不僅包含現有類型的所有成員（儘管私有成員被隱藏起來並且不可訪問），而且更重要的是它複製了基類的介面。也就是說，基類物件接收的所有消息也能被衍生類物件接收。根據類接收的消息，我們知道類的類型，因此衍生類與基類是相同的類型。

在前面的例子中，“圓是形狀”。這種透過繼承的類型等價性是理解物件導向編程含義的基本門檻之一。因為基類和衍生類都具有相同的基本介面，所以伴隨此介面的必定有某些具體實現。也就是說，當物件接收到特定消息時，必須有可執行程式碼。如果繼承一個類而不做其他任何事，則來自基類介面的方法直接進入衍生類。這意味著衍生類和基類不僅具有相同的類型，而且具有相同的行為，這麼做沒什麼特別意義。

有兩種方法可以區分新的衍生類與原始的基類。第一種方法很簡單：在衍生類中添加新方法。這些新方法不是基類介面的一部分。這意味著基類不能滿足你的所有需求，所以你添加了更多的方法。繼承的這種簡單而原始的用途有時是解決問題的完美解決方案。然而，還是要仔細考慮是否在基類中也要有這些額外的方法。這種設計的發現與疊代過程在物件導向程式設計中會經常發生。

儘管繼承有時意味著你要在介面中添加新方法（尤其是在以 **extends** 關鍵字表示繼承的 Java 中），但並非總需如此。第二種也是更重要地區分衍生類和基類的方法是改變現有基類方法的行為，這被稱為覆蓋 (overriding)。要想覆蓋一個方法，只需要在衍生類中重新定義這個方法即可。

### "是一個"與"像是一個"的關係

對於繼承可能會引發爭論：繼承應該只覆蓋基類的方法(不應該添加基類中沒有的方法)嗎？如果這樣的話，基類和衍生類就是相同的類型了，因為它們具有相同的介面。這會造成，你可以用一個衍生類物件完全替代基類物件，這叫作"純粹替代"，也經常被稱作"替代原則"。在某種意義上，這是一種處理繼承的理想方式。我們經常把這種基類和衍生類的關係稱為是一個（is-a）關係，因為可以說"圓是一個形狀"。判斷是否繼承，就看在你的類之間有無這種 is-a 關係。

有時你在衍生類添加了新的介面元素，從而擴展介面。雖然新類型仍然可以替代基類，但是這種替代不完美，原因在於基類無法訪問新添加的方法。這種關係稱為像是一個(is-like-a)關係。新類型不但擁有舊類型的介面，而且包含其他方法，所以不能說新舊類型完全相同。

![1545764820176](../images/1545764820176.png)

以空調為例，假設房間裡已經安裝好了製冷裝置的控制器，即你有了控制製冷裝置的介面。想像一下，現在空調壞了，你重新安裝了一個既製冷又制熱的熱力泵。熱力泵就像是一個（is-like-a）空調，但它可以做更多。因為當初房間的控制系統被設計成只能控制製冷裝置，所以它只能與新物件(熱力泵)的製冷部分通信。新物件的介面已經擴展了，現有控制系統卻只知道原來的介面，一旦看到這個設計，你就會發現，作為基類的製冷系統不夠一般化，應該被重新命名為"溫度控制系統"，也應該包含制熱功能，這樣的話，我們就可以使用替代原則了。上圖反映了在現實世界中進行設計時可能會發生的事情。

當你看到替代原則時，很容易會認為純粹替代是唯一可行的方式，並且使用純粹替代的設計是很好的。但有些時候，你會發現必須得在衍生(擴展)類中添加新方法(提供新的介面)。只要仔細審視，你可以很明顯地區分兩種設計方式的使用場合。

## 多態

我們在處理類的層次結構時，通常把一個物件看成是它所屬的基類，而不是把它當成具體類。透過這種方式，我們可以編寫出不局限於特定類型的程式碼。在上個“形狀”的例子中，“方法”（method）操縱的是通用“形狀”，而不關心它們是“圓”、“正方形”、“三角形”還是某種尚未定義的形狀。所有的形狀都可以被繪製、擦除和移動，因此“方法”向其中的任何代表“形狀”的物件發送消息都不必擔心物件如何處理訊息。

這樣的程式碼不會受添加的新類型影響，並且添加新類型是擴展物件導向程式以處理新情況的常用方法。 例如，你可以透過通用的“形狀”基類衍生出新的“五角形”形狀的子類，而不需要修改通用"形狀"基類的方法。透過衍生新的子類來擴展設計的這種能力是封裝變化的基本方法之一。

這種能力改善了我們的設計，且減少了軟體的維護代價。如果我們把衍生的物件類型統一看成是它本身的基類（“圓”當作“形狀”，“自行車”當作“車”，“鸕鶿”當作“鳥”等等），編譯器（compiler）在編譯時期就無法準確地知道什麼“形狀”被擦除，哪一種“車”在行駛，或者是哪種“鳥”在飛行。這就是關鍵所在：當程式接收這種消息時，程式設計師並不想知道哪段程式碼會被執行。“繪圖”的方法可以平等地應用到每種可能的“形狀”上，形狀會依據自身的具體類型執行恰當的程式碼。

如果不需要知道執行了哪部分程式碼，那我們就能添加一個新的不同執行方式的子類而不需要更改呼叫它的方法。那麼編譯器在不確定該執行哪部分程式碼時是怎麼做的呢？舉個例子，下圖的 **BirdController** 物件和通用 **Bird** 物件中，**BirdController** 不知道 **Bird** 的確切類型卻還能一起工作。從 **BirdController** 的角度來看，這是很方便的，因為它不需要編寫特別的程式碼來確定 **Bird** 物件的確切類型或行為。那麼，在呼叫 **move()** 方法時是如何保證發生正確的行為（鵝走路、飛或游泳、企鵝走路或游泳）的呢？

![Bird-example](../images/1545839316314.png)

這個問題的答案，是物件導向程式設計的妙訣：在傳統意義上，編譯器不能進行函數呼叫。由非 OOP 編譯器產生的函數呼叫會引起所謂的**早期綁定**，這個術語你可能從未聽說過，不會想過其他的函數呼叫方式。這意味著編譯器生成對特定函數名的呼叫，該呼叫會被解析為將執行的程式碼的絕對地址。

透過繼承，程式直到執行時才能確定程式碼的地址，因此發送消息給物件時，還需要其他一些方案。為了解決這個問題，物件導向語言使用**後期綁定**的概念。當向物件發送訊息時，被呼叫的程式碼直到執行時才確定。編譯器確保方法存在，並對參數和返回值執行類型檢查，但是它不知道要執行的確切程式碼。

為了執行後期綁定，Java 使用一個特殊的程式碼位來代替絕對呼叫。這段程式碼使用物件中儲存的訊息來計算方法主體的地址（此過程在多態性章節中有詳細介紹）。因此，每個物件的行為根據特定程式碼位的內容而不同。當你向物件發送消息時，物件知道該如何處理這條消息。在某些語言中，必須顯式地授予方法後期綁定屬性的靈活性。例如，C++ 使用 **virtual** 關鍵字。在這些語言中，預設情況下方法不是動態綁定的。在 Java 中，動態綁定是預設行為，不需要額外的關鍵字來實現多態性。

為了示範多態性，我們編寫了一段程式碼，它忽略了類型的具體細節，只與基類對話。該程式碼與具體類型訊息分離，因此更易於編寫和理解。而且，如果透過繼承添加了一個新類型（例如，一個六邊形），那麼程式碼對於新類型的 Shape 就像對現有類型一樣有效。因此，該程式是可擴展的。

程式碼範例：

```java
void doSomething(Shape shape) {
    shape.erase();
    // ...
    shape.draw();
}
```

此方法與任何 **Shape** 對話，因此它與所繪製和擦除的物件的具體類型無關。如果程式的其他部分使用 `doSomething()` 方法：

```java
    Circle circle = new Circle();
    Triangle triangle = new Triangle();
    Line line = new Line();
    doSomething(circle);
    doSomething(triangle);
    doSomething(line);

```

可以看到無論傳入的“形狀”是什麼，程式都正確的執行了。

![shape-example](../images/1545841270997.png)

這是一個非常令人驚奇的程式技巧。分析下面這行程式碼：

```java
    doSomething(circle);
```
當預期接收 **Shape** 的方法被傳入了 **Circle**，會發生什麼事。由於 **Circle** 也是一種 **Shape**，所
以 `doSomething(circle)` 能正確地執行。也就是說，`doSomething()` 能接收任意發送給 **Shape** 的消息。這是完全安全和合乎邏輯的事情。

這種把子類當成其基類來處理的過程叫做“向上轉型”（**upcasting**）。在物件導向的程式裡，經常利用這種方法來給程式解耦。再看下面的 `doSomething()` 程式碼範例：

```java
    shape.erase();
    // ...
    shape.draw();
```

我們可以看到程式並未這樣表達：“如果你是一個 Circle ，就這樣做；如果你是一個 Square，就那樣做...”。若那樣編寫程式碼，就需檢查 Shape 所有可能的類型，如圓、矩形等等。這顯然是非常麻煩的，而且每次添加了一種新的 Shape 類型後，都要相應地進行修改。在這裡，我們只需說：“你是一種幾何形狀，我知道你能刪掉 `erase()` 和繪製 `draw()`，你自己去做吧，注意細節。”

儘管我們沒作出任何特殊指示，程式的操作也是完全正確和恰當的。我們知道，為 Circle 呼叫`draw()` 時執行的程式碼與為一個 Square 或 Line 呼叫 `draw()` 時執行的程式碼是不同的。但在將 `draw()` 訊息發給一個匿名 Shape 時，根據 Shape 句柄當時連接的實際類型，會相應地採取正確的操作。這非常神奇，因為當 Java 編譯器為 `doSomething()` 編譯程式碼時，它並不知道自己要操作的準確類型是什麼。

儘管我們確實可以保證最終會為 Shape 呼叫 `erase()` 和 `draw()`，但並不能確定特定的 Circle，Square 或者 Line 呼叫什麼。最後，程式執行的操作卻依然是正確的，這是怎麼做到的呢？

發送消息給物件時，如果程式不知道接收的具體類型是什麼，但最終執行是正確的，這就是物件的“多態性”（Polymorphism）。物件導向的程式設計語言是透過“動態綁定”的方式來實現物件的多態性的。編譯器和執行時系統會負責對所有細節的控制；我們只需知道要做什麼，以及如何利用多態性來更好地設計程式。

## 單繼承結構

自從 C++ 引入以來，一個 OOP 問題變得尤為突出：是否所有的類都應該預設從一個基類繼承呢？這個答案在 Java 中是肯定的（實際上，除 C++ 以外的幾乎所有OOP語言中也是這樣）。在 Java 中，這個最終基類的名字就是 `Object`。

Java 的單繼承結構有很多好處。由於所有物件都具有一個公共介面，因此它們最終都屬於同一個基類。相反的，對於 C++ 所使用的多繼承的方案則是不保證所有的物件都屬於同一個基類。從向後相容的角度看，多繼承的方案更符合 C 的模型，而且受限較少。

對於完全物件導向編程，我們必須要構建自己的層次結構，以提供與其他 OOP 語言同樣的便利。我們經常會使用到新的類庫和不相容的介面。為了整合它們而花費大氣力（有可能還要用上多繼承）以獲得 C++ 樣的“靈活性”值得嗎？如果從零開始，Java 這樣的替代方案會是更好的選擇。

另外，單繼承的結構使得垃圾收集器的實現更為容易。這也是 Java 在 C++ 基礎上的根本改進之一。

由於執行期的類型訊息會存在於所有物件中，所以我們永遠不會遇到判斷不了物件類型的情況。這對於系統級操作尤其重要，例如[異常處理](#異常處理)。同時，這也讓我們的程式具有更大的靈活性。

## 集合

通常，我們並不知道解決某個具體問題需要的物件數量和持續時間，以及物件的儲存方式。那麼我們如何知悉程式在執行時需要分配的記憶體空間呢？

在物件導向的設計中，問題的解決方案有些過於輕率：建立一個新類型的物件來引用、容納其他的物件。當然，我們也可以使用多數程式語言都支援的“陣列”（array）。在 Java 中“集合”（Collection）的使用率更高。（也可稱之為“容器”，但“集合”這個稱呼更通用。）

“集合”這種類型的物件可以儲存任意類型、數量的其他物件。它能根據需要自動擴容，我們不用關心過程是如何實現的。

還好，一般優秀的 OOP 語言都會將“集合”作為其基礎包。在 C++ 中，“集合”是其標準庫的一部分，通常被稱為 STL（Standard Template Library，標準模板庫）。SmallTalk 有一套非常完整的集合庫。同樣，Java 的標準庫中也提供許多現成的集合類。

在一些庫中，一兩個泛型集合就能滿足我們所有的需求了，而在其他一些類庫（Java）中，不同類型的集合對應不同的需求：常見的有 List，常用於儲存序列；Map，也稱為關聯陣列，常用於將物件與其他物件關聯；Set，只能儲存非重複的值；其他還包括如佇列（Queue）、樹（Tree）、堆疊（Stack）、堆（Heap）等等。從設計的角度來看，我們真正想要的是一個能夠解決某個問題的集合。如果一種集合就滿足所有需求，那麼我們就不需要剩下的了。之所以選擇集合有以下兩個原因：

1. 集合可以提供不同類型的介面和外部行為。堆疊、佇列的應用場景和集合、列表不同，它們中的一種提供的解決方案可能比其他靈活得多。

2. 不同的集合對某些操作有不同的效率。例如，List 的兩種基本類型：ArrayList 和 LinkedList。雖然兩者具有相同介面和外部行為，但是在某些操作中它們的效率差別很大。在 ArrayList 中隨機尋找元素是很高效的，而 LinkedList 隨機尋找效率低下。反之，在 LinkedList 中插入元素的效率要比在 ArrayList 中高。由於底層資料結構的不同，每種集合類型在執行相同的操作時會表現出效率上的差異。

我們可以一開始使用 LinkedList 構建程式，在最佳化系統效能時改用 ArrayList。透過對 List 介面的抽象，我們可以很容易地將 LinkedList 改為 ArrayList。

在 Java 5 泛型出來之前，集合中儲存的是通用類型 `Object`。Java 單繼承的結構意味著所有元素都基於 `Object` 類，所以在集合中可以儲存任何類型的資料，易於重用。要使用這樣的集合，我們先要往集合添加元素。由於 Java 5 版本前的集合只儲存 `Object`，當我們往集合中添加元素時，元素便向上轉型成了 `Object`，從而遺失自己原有的類型特性。這時我們再從集合中取出該元素時，元素的類型變成了 `Object`。那麼我們該怎麼將其轉回原先具體的類型呢？這裡，我們使用了強制類型轉換將其轉為更具體的類型，這個過程稱為物件的“向下轉型”。通過“向上轉型”，我們知道“圓形”也是一種“形狀”，這個過程是安全的。可是我們不能從“Object”看出其就是“圓形”或“形狀”，所以除非我們能確定元素的具體類型訊息，否則“向下轉型”就是不安全的。也不能說這樣的錯誤就是完全危險的，因為一旦我們轉化了錯誤的類型，程式就會執行出錯，拋出“執行時異常”（RuntimeException）。（後面的章節會提到） 無論如何，我們要尋找一種在取出集合元素時確定其具體類型的方法。另外，每次取出元素都要做額外的“向下轉型”對程式和程式設計師都是一種開銷。以某種方式建立集合，以確認儲存元素的具體類型，減少集合元素“向下轉型”的開銷和可能出現的錯誤難道不好嗎？這種解決方案就是：參數化類型機制（Parameterized Type Mechanism）。

參數化類型機制可以使得編譯器能夠自動識別某個 `class` 的具體類型並正確地執行。舉個例子，對集合的參數化類型機制可以讓集合僅接受“形狀”這種類型的元素，並以“形狀”類型取出元素。Java 5 版本支援了參數化類型機制，稱之為“泛型”（Generic）。泛型是 Java 5 的主要特性之一。你可以按以下方式向 ArrayList 中添加 Shape（形狀）：

```java
    ArrayList<Shape> shapes = new ArrayList<>();
```

泛型的應用，讓 Java 的許多標準庫和元件都發生了改變。在本書的程式碼範例中，你也會經常看到泛型的身影。

## 物件建立與生命週期

我們在使用物件時要注意的一個關鍵問題就是物件的建立和銷毀方式。每個物件的生存都需要資源，尤其是記憶體。為了資源的重複利用，當物件不再被使用時，我們應該及時釋放資源，清理記憶體。

在簡單的程式場景下，物件的清理並不是問題。我們建立物件，按需使用，最後銷毀它。然而，情況往往要比這更複雜：

假設，我們正在為機場設計一個空中交通管制的系統（該例也適用於倉庫貨櫃管理、影帶出租或者寵物寄養倉庫系統）。第一步比較簡單：建立一個用來儲存飛機的集合，每當有飛機進入交通管制區域時，我們就建立一個“飛機”物件並將其加入到集合中，等到飛機離開時將其從這個集合中清除。與此同時，我們還需要一個紀錄飛機訊息的系統，也許這些資料不像主要控制功能那樣引人注意。比如，我們要記錄所有飛機中的小型飛機的的訊息（比如飛行計劃）。此時，我們又建立了第二個集合來記錄所有小型飛機。 每當建立一個“飛機”物件的時候，將其放入第一個集合；若它屬於小型飛機，也必須同時將其放入第二個集合裡。

現在問題開始棘手了：我們怎麼知道何時該清理這些物件呢？當某一個系統處理完成，而其他系統可能還沒有處理完成。這樣的問題在其他的場景下也可能發生。在 C++ 程式設計中，當使用完一個物件後，必須明確將其刪除，這就讓問題變複雜了。

物件的資料在哪？它的生命週期是怎麼被控制的？ 在 C++ 設計中採用的觀點是效率第一，因此它將選擇權交給了程式設計師。為了獲得最大的執行時速度，程式設計師可以在編寫程式時，透過將物件放在堆疊（Stack，有時稱為自動變數或作用域變數）或靜態儲存區域（static storage area）中來確定記憶體占用和生存時間。這些區域的物件會被優先分配記憶體和釋放。這種控制在某些情況下非常有用。

然而相對的，我們也犧牲了程式的靈活性。因為在編寫程式碼時，我們必須要弄清楚物件的數量、生存時間還有類型。如果我們要用它來解決一個相當普遍的問題時（如電腦輔助設計、倉庫管理或空中交通管制等），限制就太大了。

第二種方法是在堆記憶體（Heap）中動態地建立物件。在這種方式下，直到程式執行我們才能確定需要建立的物件數量、生存時間和類型。什麼時候需要，什麼時候在堆記憶體中建立。 因為記憶體的占用是動態管理的，所以在執行時，在堆記憶體上開闢空間所需的時間可能比在堆疊記憶體上要長（但也不一定）。在堆疊記憶體開闢和釋放空間通常是一條將堆疊指標向下移動和一條將堆疊指標向上移動的組語指令。開闢堆記憶體空間的時間取決於記憶體機制的設計。

動態方法有這樣一個合理假設：物件通常是複雜的，相比於物件建立的整體開銷，尋找和釋放記憶體空間的開銷微不足道。（原文：*The dynamic approach makes the generally logical assumption that objects tend to be complicated, so the extra overhead of finding storage and releasing that storage will not have an important impact on the creation of an object.*）此外，更好的靈活性對於問題的解決至關重要。

Java 使用動態記憶體分配。每次建立物件時，使用 `new` 關鍵字構建該物件的動態實例。這又帶來另一個問題：物件的生命週期。較之堆記憶體，在堆疊記憶體中建立物件，編譯器能夠確定該物件的生命週期並自動銷毀它；然而如果你在堆記憶體建立物件的話，編譯器是不知道它的生命週期的。在 C++ 中你必須以編程方式確定何時銷毀物件，否則可能導致記憶體洩漏。Java 的記憶體管理是建立在垃圾收集器上的，它能自動發現物件不再被使用並釋放記憶體。垃圾收集器的存在帶來了極大的便利，它減少了我們之前必須要跟蹤的問題和編寫相關程式碼的數量。因此，垃圾收集器提供了更進階別的保險，以防止潛在的記憶體洩漏問題，這個問題使得許多 C++ 項目沒落。

Java 的垃圾收集器被設計用來解決記憶體釋放的問題（雖然這不包括物件清理的其他方面）。垃圾收集器知道物件什麼時候不再被使用並且自動釋放記憶體。結合單繼承和僅可在堆中建立物件的機制，Java 的編碼過程比用 C++ 要簡單得多。我們所要做的決定和要克服的障礙也會少很多！

## 異常處理

自程式語言被發明以來，程式的錯誤處理一直都是個難題。因為很難設計出一個好的錯誤處理方案，所以許多程式語言都忽略了這個問題，把這個問題丟給了程式類庫的設計者。他們提出了在許多情況下都可以工作但很容易被規避的半途而廢的措施，通常只需忽略錯誤。多數錯誤處理方案的主要問題是：它們依賴程式設計師之間的約定俗成而不是語言層面的限制。換句話說，如果程式設計師趕時間或沒想起來，這些方案就很容易被忘記。

異常處理機制將程式錯誤直接交給程式語言甚至是作業系統。“異常”（Exception）是一個從出錯點“拋出”（thrown）後能被特定類型的異常處理程序捕獲(catch)的一個物件。它不會干擾程式的正常執行，僅當程式出錯的時候才被執行。這讓我們的編碼更簡單：不用再反覆檢查錯誤了。另外，異常不像方法返回的錯誤值和方法設定用來表示發生錯誤的標誌位那樣可以被忽略。異常的發生是不會被忽略的，它終究會在某一時刻被處理。

最後，“異常機制”提供了一種可靠地從錯誤狀況中復原的方法，使得我們可以編寫出更健壯的程式。有時你只要處理好拋出的異常情況並復原程式的執行即可，無需退出。

Java 的異常處理機制在程式語言中脫穎而出。Java 從一開始就內建了異常處理，因此你不得不使用它。這是 Java 語言唯一接受的錯誤報告方法。如果沒有編寫適當的異常處理程式碼，你將會收到一條編譯時錯誤消息。這種有保障的一致性有時會讓程式的錯誤處理變得更容易。值得注意的是，異常處理並不是物件導向的特性。儘管在物件導向的語言中異常通常由物件表示，但是在物件導向語言之前也存在異常處理。

## 本章小結

程序導向程式包含資料定義和函數呼叫。要找到程式的意圖，你必須要在腦中建立一個模型，弄清函數呼叫和更底層的概念。這些程式令人困擾，因為它們的表示更多地面向電腦而不是我們要解決的問題，這就是我們在設計程式時需要中間表示的原因。OOP 在程序導向編程的基礎上增加了許多新的概念，所以有人會認為使用 Java 來編程會比同等的程序導向編程要更複雜。在這裡，我想給大家一個驚喜：通常按照 Java 規範編寫的程式會比程序導向程式更容易被理解。

你看到的是物件的概念，這些概念是站在“問題空間”的（而不是站在電腦角度的“解決方案空間”），以及發送消息給物件以指示該空間中的活動。物件導向編程的一個優點是：設計良好的 Java 程式碼更容易被人閱讀理解。由於 Java 類庫的復用性，通常程式要寫的程式碼也會少得多。

OOP 和 Java 不一定適合每個人。評估自己的需求以及與現有方案作比較是很重要的。請充分考慮後再決定是不是選擇 Java。如果在可預見的未來，Java 並不能很好的滿足你的特定需求，那麼你應該去尋找其他替代方案（特別是，我推薦看 Python）。如果你依然選擇 Java 作為你的開發語言，我希望你至少應該清楚你選擇的是什麼，以及為什麼選擇這個方向。
<!-- 分頁 -->

<div style="page-break-after: always;"></div>
